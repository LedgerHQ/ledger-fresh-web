import { useState } from "react";
import styles from "./Webauthn.module.css";
import { Button } from "@/components/Button";
import Main from "@/components/MainContainer";
import { getKeyCredentialCreationOptions } from "@/utils/webauthn";
import Image from "next/image";
import Link from "next/link";
import { useRouter } from "next/router";
import { create } from "@github/webauthn-json/browser-ponyfill";
import { addAccount } from "@/services/accountStorage/account.storage";
import { addTransaction } from "@/services/transactionStorage/transaction.storage";

function ArrayBufferToString(
  buffer: Buffer,
  encoding: BufferEncoding | undefined
) {
  if (encoding == null) encoding = "utf8";

  return Buffer.from(buffer).toString(encoding);
}

const network: any = process.env.NEXT_PUBLIC_NETWORK || "goerli-alpha";

export default function Webauthn() {
  const [username, setUsername] = useState<string>("");
  const router = useRouter();

  const register = async () => {
    try {
      // fetch the challenge and the userId
      const [challengeRes, userIdRes] = await Promise.all([
        fetch("/api/webauthn/challenge"),
        fetch("/api/userId", {
          method: "POST",
          body: JSON.stringify({ username }),
        }),
      ]);
      const [challenge, { userId }] = await Promise.all([
        challengeRes.arrayBuffer(),
        userIdRes.json(),
      ]);

      // get the current domain
      const currentDomain = window.location.hostname;

      // create the options for webauthn
      const options = getKeyCredentialCreationOptions(
        challenge,
        currentDomain,
        username,
        Buffer.from(userId, "utf8")
      );

      // create the credential
      const credentials = await create(options);

      if (!credentials) throw "";
      if (!options.publicKey) throw "";

      // @ts-ignore
      const pubKeyBrut = credentials.response.getPublicKey();
      const pubKey = ArrayBufferToString(
        pubKeyBrut.slice(pubKeyBrut.byteLength - 65),
        "hex"
      );

      const res: { accountAddress: string; transaction_hash: string } =
        await fetch("/api/deployer/deploy", {
          method: "POST",
          body: pubKey,
        }).then((response) => response.json());

      addAccount({
        networkId: network,
        name: username,
        address: res.accountAddress,
        authenticatorId: credentials.id,
      });

      addTransaction({
        networkId: network,
        hash: res.transaction_hash,
        type: 1,
        data: [res.accountAddress],
        hidden: true,
      });

      router.push("/created");

      /**
       * @TODO redirect */

      /**
       * @TODO At this point, the challenge, the username and the credential need to be returned to the server
       * The server has the responsibility to verify if the challenge matches the one previously returned
       * and it must validate the certificate generated by the authenticator
       * If everything is good, the certificate and the username would be stored
       */
    } catch (e) {
      console.error(e);
      throw e;
    }
  };

  return (
    <div className="page">
      <Main>
        <Link href="/create" className={styles.icon}>
          <Image
            src="/Icons/arrow-left-rtl.svg"
            alt="back"
            width={20}
            height={20}
            priority
          />
        </Link>
        <label htmlFor="username">
          <h2 className={styles.title}>Give a name to your wallet</h2>
          <p className={styles.subtitle}>
            This name will be only displayed to you and stored locally.
          </p>
        </label>
        <input
          className={styles.input}
          name="username"
          type="text"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          placeholder="Wallet name"
        />
      </Main>
      <div className={styles.buttonRow}>
        <Button variant={username ? "primary" : "secondary"} onClick={register}>
          Create a new wallet
        </Button>
      </div>
    </div>
  );
}
